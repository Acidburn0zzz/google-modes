extends "./c.grammar"

skip whitespace {
  Statement {
    Class |
    namespace declName? ("=" variableName ";" | Block) |
    throw Expression ";" |
    try Block (catch "{" Type declName? "}" Block)* |
    asm "{" string "}" |
    export? template TemplateArgs Statement |
    super
  }

  TypeSuffix {
    TemplateArgs |
    super
  }

  ExpressionPrefix {
    delete | new ("(" Expression ")")? | super
  }

  Type {
    typename Type | super
  }

  TemplateArgs {
    "<" ListOf(TypeParam | modifier* declName Initializer?) ">"
  }

  TypeParam {
     (template TemplateArgs)? (class | typename) declName ("=" variableName)?
  }

  Class {
    (class | structUnion) declName (":" virtual? access? variableName) ClassBody
  }

  context ClassBody {
    "{" (access ":" | ClassMember)* "}"
  }

  ClassMember {
    (friend | Type | modifier)* declName (Initializer ";" | FunctionDef)
  }
}

tokens {
  namespace { kw("namespace") }

  typename { kw("typename") }

  new { kw("new") }
  delete { kw("delete") }
  try { kw("try") }
  catch { kw("catch") }
  throw { kw("throw") }
  asm { kw("asm") }
  export { kw("export") }
  template { kw("template") }
  class { kw("class") }
  virtual { kw("virtual") }
  access { kw("private" | "public" | "protected") }
  friend { kw("friend") }

  qualifier { identifier ~(spaceChar* "::") } = "meta"

  variableName { "::"? qualifier* identifier }

  modifier { kw("inline" | "virtual" | "explicit") | super }

  prefixOp {
    typename | super
  } = "operator"
}
