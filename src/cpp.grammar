extends "./c.grammar"

skip whitespace {
  Statement {
    Class |
    namespace declName? (op("=") variableName ";" | Block) |
    throw Expression ";" |
    try Block (catch "{" Type declName? "}" Block)* |
    asm "{" string "}" |
    using (typename Type | namespace? variableName) ";" |
    export? template TemplateParams Statement |
    &constructorAhead declName FunctionDef |
    nameQualifier+ (MaybeType DeclRest | qualifiedVariableName ExpressionSuffix* ";") |
    super
  }

  TypeSuffix {
    TemplateArgs |
    "::" Type |
    super
  }

  BaseExpression {
    this |
    Lambda |
    cast "<" Type ">" "(" Expression ")" |
    super
  }

  Lambda {
    "[" ListOf("&" variableName? | "=" | this) FunctionDef
  }

  context FunctionDef {
    ParamList
    qualifier*
    ("&" | "&&")?
    (noexcept ("(" Expression ")")? | throw "(" ListOf(Type) ")")?
    ("->" Type)?
    (":" ListOf(CtorInitializer))?
    (";" | Block)
  }

  CtorInitializer { fieldName ("(" Expression ")" | "{" ListOf(Expression) "}") }

  ExpressionPrefix {
    delete | new ("(" Expression ")")? | super
  }

  Type {
    typename Type | super
  }

  TemplateParams {
    "<" ListOf(TypeParam | modifier* declName Initializer?) ">"
  }

  TemplateArgs {
    "<" ListOf(TypeParam | modifier* typeName Initializer?) ">"
  }

  TypeParam {
     (template TemplateArgs)? (class | typename) declName (op("=") variableName)?
  }

  Class {
    (class | structUnion) (alignas "(" number ")")? declName (":" virtual? access? variableName) ClassBody
  }

  context ClassBody {
    "{" (access ":" | ClassMember)* "}"
  }

  ClassMember {
    (friend | Type | modifier)* (operator (binOp | prefixOp) | declName) (Initializer ";" | FunctionDef)
  }
}

tokens {
  namespace { kw("namespace") }

  typename { kw("typename") }

  new { kw("new") }
  delete { kw("delete") }
  this { kw("this") }
  try { kw("try") }
  catch { kw("catch") }
  throw { kw("throw") }
  noexcept { kw("noexcept") }
  asm { kw("asm") }
  export { kw("export") }
  template { kw("template") }
  class { kw("class") }
  virtual { kw("virtual") }
  access { kw("private" | "public" | "protected") }
  friend { kw("friend") }
  operator { kw("operator") }
  using { kw("using") }
  alignas { kw("alignas") }
  cast { kw(("dynamic" | "static" | "const" | "reinterpret") "_cast") }

  variableName { nameQualifier+ qualifiedVariableName | (unqualifiedCallee | unqualifiedVariableName) }

  modifier { kw("inline" | "virtual" | "explicit") | super }

  prefixOp {
    typename | super
  } = "operator"

  number {
    ("0x" (digit | "a"-"f" | "A"-"F" | "'")+ |
     "0b" ("0" | "1" | "'")+ |
     (digit digits ("." digits)? | "." digit digits) (("e" | "E") "-"? digits)?)
    ("L" | "l" | "U" | "u" | "F" | "f")?
  } = "number"
}

digits { (digit | "'")* }

nameQualifier { "::" | identifier " "* "::" } = "meta"

declName { nameQualifier* unqualifiedDeclName }

unqualifiedDeclName { "~"? identifier }  = "def"

unqualifiedCallee { identifier ~"(" } = "builtin"

unqualifiedVariableName { "~"? identifier }  = "variable"

qualifiedVariableName { unqualifiedVariableName }  = "qualified"

typeName { nameQualifier* unqualifiedTypeName }

unqualifiedTypeName { identifier } = "type"

maybeTypeName {
 unqualifiedTypeName ~(!identifierChar whitespace TypeSuffix* whitespace identifierStart)
}

